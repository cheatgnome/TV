const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const cron = require('node-cron');

class PythonRunner {
    constructor() {
        this.scriptPath = path.join(__dirname, 'temp_script.py');
        this.m3uOutputPath = path.join(__dirname, 'generated_playlist.m3u');
        this.lastExecution = null;
        this.lastError = null;
        this.isRunning = false;
        this.scriptUrl = null;
        this.cronJob = null;
        this.updateInterval = null;

        // Create temp directory if missing
        if (!fs.existsSync(path.join(__dirname, 'temp'))) {
            fs.mkdirSync(path.join(__dirname, 'temp'));
        }
    }

    /**
     * Download the Python script from the provided URL
     * @param {string} url - Script URL
     * @returns {Promise<boolean>} - true if download succeeded
     */
    async downloadScript(url) {
        try {
            console.log(`\n=== Downloading Python script from ${url} ===`);
            this.scriptUrl = url;

            const response = await axios.get(url, { responseType: 'text' });
            fs.writeFileSync(this.scriptPath, response.data);

            console.log('✓ Python script downloaded successfully');
            return true;
        } catch (error) {
            console.error('❌ Error downloading Python script:', error.message);
            this.lastError = `Download error: ${error.message}`;
            return false;
        }
    }

    /**
     * Execute the downloaded Python script
     * @returns {Promise<boolean>} - true if execution succeeded
     */
    async executeScript() {
        if (this.isRunning) {
            console.log('⚠️ An execution is already in progress, please wait...');
            return false;
        }

        if (!fs.existsSync(this.scriptPath)) {
            console.error('❌ Python script not found. Run downloadScript() first');
            this.lastError = 'Python script not found';
            return false;
        }

        try {
            this.isRunning = true;
            console.log('\n=== Running Python script ===');

            // Remove existing M3U files before running
            this.cleanupM3UFiles();

            // Check if Python is installed
            await execAsync('python3 --version').catch(() =>
                execAsync('python --version')
            );

            // Execute the Python script
            const pythonCmd = process.platform === 'win32' ? 'python' : 'python3';
            const { stdout, stderr } = await execAsync(`${pythonCmd} ${this.scriptPath}`);

            if (stderr) {
                console.warn('⚠️ Warning during execution:', stderr);
            }

            console.log('Output script:', stdout);

            // Find any generated M3U/M3U8 file and rename it
            const foundFiles = this.findAllM3UFiles();

            if (foundFiles.length > 0) {
                console.log(`✓ Found ${foundFiles.length} M3U/M3U8 files`);

                // Take the first file found and rename it
                const sourcePath = foundFiles[0];

                // If destination file already exists, delete it
                if (fs.existsSync(this.m3uOutputPath)) {
                    fs.unlinkSync(this.m3uOutputPath);
                }

                // Rename or copy the file
                if (sourcePath !== this.m3uOutputPath) {
                    fs.copyFileSync(sourcePath, this.m3uOutputPath);
                    console.log(`✓ File renamed/copied from "${sourcePath}" to "${this.m3uOutputPath}"`);

                    // Optional: delete the original file after copy
                    // fs.unlinkSync(sourcePath);
                }

                this.lastExecution = new Date();
                this.lastError = null;
                this.isRunning = false;
                return true;
            } else {
                // Try to find paths in output text
                const possiblePath = this.findM3UPathFromOutput(stdout);
                if (possiblePath && fs.existsSync(possiblePath)) {
                    fs.copyFileSync(possiblePath, this.m3uOutputPath);
                    console.log(`✓ M3U file found at ${possiblePath} and copied to ${this.m3uOutputPath}`);
                    this.lastExecution = new Date();
                    this.lastError = null;
                    this.isRunning = false;
                    return true;
                }

                console.error('❌ No M3U file found after script execution');
                this.lastError = 'M3U file not generated by the script';
                this.isRunning = false;
                return false;
            }
        } catch (error) {
            console.error('❌ Error during Python script execution:', error.message);
            this.lastError = `Execution error: ${error.message}`;
            this.isRunning = false;
            return false;
        }
    }

    /**
     * Schedule automatic script updates
     * @param {string} timeFormat - Time format "HH:MM" or "H:MM"
     * @returns {boolean} - true if scheduling succeeded
     */
    scheduleUpdate(timeFormat) {
        // Stop existing schedules
        this.stopScheduledUpdates();

        // Validate time format
        if (!timeFormat || !/^\d{1,2}:\d{2}$/.test(timeFormat)) {
            console.error('❌ Invalid time format. Use HH:MM or H:MM');
            this.lastError = 'Invalid time format. Use HH:MM or H:MM';
            return false;
        }

        try {
            // Extract hours and minutes
            const [hours, minutes] = timeFormat.split(':').map(Number);

            if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                console.error('❌ Invalid time. Hours: 0-23, Minutes: 0-59');
                this.lastError = 'Invalid time. Hours: 0-23, Minutes: 0-59';
                return false;
            }

            // Create a cron schedule
            // If it's 0:30, run every 30 minutes
            // If it's 1:00, run every hour
            // If it's 12:00, run every 12 hours
            let cronExpression;

            if (hours === 0) {
                // Run every X minutes
                cronExpression = `*/${minutes} * * * *`;
                console.log(`✓ Schedule set: every ${minutes} minutes`);
            } else {
                // Run every X hours
                cronExpression = `${minutes} */${hours} * * *`;
                console.log(`✓ Schedule set: every ${hours} hours and ${minutes} minutes`);
            }

            this.cronJob = cron.schedule(cronExpression, async () => {
                console.log(`\n=== Automatic Python script run (${new Date().toLocaleString()}) ===`);
                const success = await this.executeScript();

                // After script execution, update cache if needed
                if (success) {
                    try {
                        // Use the URL currently configured in cache
                        const currentM3uUrl = global.CacheManager.cache.m3uUrl;

                        if (currentM3uUrl) {
                            console.log('\n=== Cache rebuild after automatic script execution ===');
                            console.log(`Using current URL: ${currentM3uUrl}`);
                            await global.CacheManager.rebuildCache(currentM3uUrl);
                            console.log('✓ Cache rebuilt successfully after automatic execution');
                        } else {
                            console.log('❌ No M3U URL configured in cache, cannot rebuild');
                        }
                    } catch (cacheError) {
                        console.error('❌ Error rebuilding cache after automatic execution:', cacheError);
                    }
                }
            });

            this.updateInterval = timeFormat;
            console.log(`✓ Automatic update configured: ${timeFormat}`);
            return true;
        } catch (error) {
            console.error('❌ Scheduling error:', error.message);
            this.lastError = `Scheduling error: ${error.message}`;
            return false;
        }
    }

    /**
     * Stop scheduled updates
     */
    stopScheduledUpdates() {
        if (this.cronJob) {
            this.cronJob.stop();
            this.cronJob = null;
            this.updateInterval = null;
            console.log('✓ Automatic updates stopped');
            return true;
        }
        return false;
    }

    /**
     * Remove any existing M3U/M3U8 files
     */

    cleanupM3UFiles() {
        try {
            // Find all M3U and M3U8 files in the directory
            const dirFiles = fs.readdirSync(__dirname);
            const m3uFiles = dirFiles.filter(file =>
                file.endsWith('.m3u') || file.endsWith('.m3u8')
            );

            // Delete each M3U/M3U8 file found
            m3uFiles.forEach(file => {
                const fullPath = path.join(__dirname, file);
                try {
                    fs.unlinkSync(fullPath);
                    console.log(`File ${fullPath} deleted`);
                } catch (e) {
                    console.error(`Error deleting file ${fullPath}:`, e.message);
                }
            });

            console.log(`✓ Deleted ${m3uFiles.length} M3U/M3U8 files`);
        } catch (error) {
            console.error('❌ Error cleaning M3U files:', error.message);
        }
    }
    /**
     * Find all M3U or M3U8 files in the directory
     * @returns {string[]} - Array of found M3U file paths
     */
    findAllM3UFiles() {
        try {
            const dirFiles = fs.readdirSync(__dirname);
            return dirFiles
                .filter(file => file.endsWith('.m3u') || file.endsWith('.m3u8'))
                .map(file => path.join(__dirname, file));
        } catch (error) {
            console.error('Error searching for M3U files:', error.message);
            return [];
        }
    }

    /**
     * Find an M3U file path in script output
     * @param {string} output - Python script output
     * @returns {string|null} - M3U file path or null if not found
     */
    findM3UPathFromOutput(output) {
        // Look for paths ending with .m3u or .m3u8
        const m3uPathRegex = /[\w\/\\\.]+\.m3u8?\b/g;
        const matches = output.match(m3uPathRegex);

        if (matches && matches.length > 0) {
            return matches[0];
        }

        return null;
    }

    /**
     * Read the generated M3U file content
     * @returns {string|null} - M3U file content or null if missing
     */
    // Add this function to python-runner.js, right before getM3UContent()

    /**
     * Add the special channel to regenerate the playlist at the end of the M3U file
     * @returns {boolean} - true if the operation succeeded
     */
    addRegenerateChannel() {
        try {
            if (!fs.existsSync(this.m3uOutputPath)) {
                console.error('❌ M3U file not found, unable to add regenerate channel');
                return false;
            }

            console.log('Adding regenerate channel to M3U file...');

            // Read the current file content
            const currentContent = fs.readFileSync(this.m3uOutputPath, 'utf8');

            // Prepara l'entry del canale speciale

            const specialChannel = `
#EXTINF:-1 tvg-id="rigeneraplaylistpython" tvg-name="Regenerate Playlist (Python)" tvg-logo="https://raw.githubusercontent.com/mccoy88f/OMG-TV-Stremio-Addon/refs/heads/main/tv.png" group-title="~SETTINGS~",Regenerate Playlist (Python)
http://127.0.0.1/regenerate`;

            // Check if the channel already exists in the file
            if (currentContent.includes('tvg-id="rigeneraplaylistpython"')) {
                console.log('Regenerate channel already present in M3U file');
                return true;
            }

            // Append the special channel to the end of the file
            fs.appendFileSync(this.m3uOutputPath, specialChannel);
            console.log('✓ Regenerate channel added successfully to M3U file');

            return true;
        } catch (error) {
            console.error('❌ Error adding regenerate channel:', error.message);
            return false;
        }
    }

    // Modifica la funzione executeScript per chiamare addRegenerateChannel
    async executeScript() {
        if (this.isRunning) {
            console.log('⚠️ Un\'esecuzione è già in corso, attendere...');
            return false;
        }

        if (!fs.existsSync(this.scriptPath)) {
            console.error('❌ Python script not found. Run downloadScript() first');
            this.lastError = 'Python script not found';
            return false;
        }

        try {
            this.isRunning = true;
            console.log('\n=== Running Python script ===');

            // Remove existing M3U files before running
            this.cleanupM3UFiles();

            // Check if Python is installed
            await execAsync('python3 --version').catch(() =>
                execAsync('python --version')
            );

            // Execute the Python script
            const pythonCmd = process.platform === 'win32' ? 'python' : 'python3';
            const { stdout, stderr } = await execAsync(`${pythonCmd} ${this.scriptPath}`);

            if (stderr) {
                console.warn('⚠️ Warning during execution:', stderr);
            }

            console.log('Output script:', stdout);

            // Find any generated M3U/M3U8 file and rename it
            const foundFiles = this.findAllM3UFiles();

            if (foundFiles.length > 0) {
                console.log(`✓ Found ${foundFiles.length} M3U/M3U8 files`);

                // Take the first file found and rename it
                const sourcePath = foundFiles[0];

                // If destination file already exists, delete it
                if (fs.existsSync(this.m3uOutputPath)) {
                    fs.unlinkSync(this.m3uOutputPath);
                }

                // Rename or copy the file
                if (sourcePath !== this.m3uOutputPath) {
                    fs.copyFileSync(sourcePath, this.m3uOutputPath);
                    console.log(`✓ File renamed/copied from "${sourcePath}" to "${this.m3uOutputPath}"`);

                    // Optional: delete the original file after copy
                    // fs.unlinkSync(sourcePath);
                }

                // Add regenerate channel
                this.addRegenerateChannel();

                this.lastExecution = new Date();
                this.lastError = null;
                this.isRunning = false;
                return true;
            } else {
                // Try to find paths in output text
                const possiblePath = this.findM3UPathFromOutput(stdout);
                if (possiblePath && fs.existsSync(possiblePath)) {
                    fs.copyFileSync(possiblePath, this.m3uOutputPath);
                    console.log(`✓ M3U file found at ${possiblePath} and copied to ${this.m3uOutputPath}`);

                    // Add regenerate channel
                    this.addRegenerateChannel();

                    this.lastExecution = new Date();
                    this.lastError = null;
                    this.isRunning = false;
                    return true;
                }

                console.error('❌ No M3U file found after script execution');
                this.lastError = 'M3U file not generated by the script';
                this.isRunning = false;
                return false;
            }
        } catch (error) {
            console.error('❌ Error during Python script execution:', error.message);
            this.lastError = `Execution error: ${error.message}`;
            this.isRunning = false;
            return false;
        }
    }

    getM3UContent() {
        try {
            if (fs.existsSync(this.m3uOutputPath)) {
                return fs.readFileSync(this.m3uOutputPath, 'utf8');
            }

            // If the standard file doesn't exist, look for other M3U files
            const files = this.findAllM3UFiles();
            if (files.length > 0) {
                return fs.readFileSync(files[0], 'utf8');
            }

            return null;
        } catch (error) {
            console.error('❌ Error reading M3U file:', error.message);
            return null;
        }
    }

    /**
     * Return the generated M3U file path
     * @returns {string} - M3U file path
     */
    getM3UPath() {
        return this.m3uOutputPath;
    }

    /**
     * Return current status
     * @returns {Object} - Current status
     */
    getStatus() {
        const m3uFiles = this.findAllM3UFiles();

        return {
            isRunning: this.isRunning,
            lastExecution: this.lastExecution ? this.formatDate(this.lastExecution) : 'Mai',
            lastError: this.lastError,
            m3uExists: fs.existsSync(this.m3uOutputPath),
            m3uFiles: m3uFiles.length,
            scriptExists: fs.existsSync(this.scriptPath),
            scriptUrl: this.scriptUrl,
            updateInterval: this.updateInterval,
            scheduledUpdates: this.cronJob !== null
        };
    }

    /**
     * Formatta una data in formato italiano
     * @param {Date} date - La data da formattare
     * @returns {string} - La data formattata
     */
    formatDate(date) {
        return date.toLocaleString('it-IT', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }
}

module.exports = new PythonRunner();
